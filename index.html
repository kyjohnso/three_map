<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Terrain App</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #ui { position: absolute; top: 10px; left: 10px; background: rgba(255, 255, 255, 0.8); padding: 10px; border-radius: 4px; }
    input { width: 100px; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Lat: <input type="text" id="lat" value="0"></label><br>
    <label>Lon: <input type="text" id="lon" value="0"></label><br>
    <label>Zoom: <input type="text" id="zoom" value="6"></label><br>
    <button id="updateBtn">Update</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, -15, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    const latInput = document.getElementById('lat');
    const lonInput = document.getElementById('lon');
    const zoomInput = document.getElementById('zoom');
    const updateBtn = document.getElementById('updateBtn');

    updateBtn.addEventListener('click', updateTerrain);

    let currentMesh;

    function getTileSizeMeters(lat, zoom) {
      const earthCircumference = 40075017;
      return (earthCircumference * Math.cos(lat * Math.PI / 180)) / Math.pow(2, zoom);
    }

    async function getTerrainTexture(x, y, z) {
    //   const tileUrl = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
      const tileUrl = `https://tile.opentopomap.org/${z}/${x}/${y}.png`;
      const loader = new THREE.TextureLoader();
      return loader.loadAsync(tileUrl);
    }

    async function getTerrainHeight(x, y, z) {
      const elevationUrl = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`;
      const img = await new Promise((resolve) => {
        const image = new Image();
        image.crossOrigin = 'Anonymous';
        image.onload = () => resolve(image);
        image.src = elevationUrl;
      });
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      const pixels = ctx.getImageData(0, 0, 256, 256).data;
      const heights = [];
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const height = (r * 256 + g + b / 256) - 32768;
        heights.push(height);
      }
      return heights;
    }

    async function buildTerrain(lat, lon, zoom) {
      if (currentMesh) {
        currentMesh.geometry.dispose();
        currentMesh.material.dispose();
        scene.remove(currentMesh);
      }

      const tileSizeMeters = getTileSizeMeters(lat, zoom);
      const x = long2tile(lon, zoom);
      const y = lat2tile(lat, zoom);
      const geometry = new THREE.PlaneGeometry(10, 10, 255, 255);
      const heights = await getTerrainHeight(x, y, zoom);

      const scaleHeight = 10 / tileSizeMeters;
      geometry.attributes.position.array.forEach((_, idx) => {
        geometry.attributes.position.array[idx * 3 + 2] = heights[idx] * scaleHeight;
      });
      geometry.computeVertexNormals();

      const texture = await getTerrainTexture(x, y, zoom);
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
      currentMesh = new THREE.Mesh(geometry, material);
      currentMesh.rotation.x = -Math.PI / 2;
      scene.add(currentMesh);
    }

    function updateTerrain() {
      const lat = parseFloat(latInput.value);
      const lon = parseFloat(lonInput.value);
      const zoom = parseInt(zoomInput.value);
      buildTerrain(lat, lon, zoom);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    function long2tile(lon, zoom) {
      return Math.floor(((lon + 180) / 360) * Math.pow(2, zoom));
    }

    function lat2tile(lat, zoom) {
      return Math.floor(((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) * Math.pow(2, zoom));
    }

    updateTerrain();
  </script>
</body>
</html>
